<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>UPSSSC Junior Assistant Typing Test (EN ➜ HI)</title>

<style>
  @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap');

  :root{
    --bg:#f3f5f7; --card:#ffffff; --muted:#6b7280; --text:#0f172a;
    --accent:#22c55e; --accent-700:#16a34a; --danger:#ef4444; --warning:#f59e0b;
    --ring:0 1px 2px rgba(0,0,0,.04), 0 4px 16px rgba(2,6,23,.10);
    --soft:0 1px 2px rgba(2,6,23,.05); --radius:14px;
    --cur-yellow:#fef08a; --err-red:#b91c1c;
  }
  *{box-sizing:border-box}
  body{margin:0; font:14px/1.6 Inter,system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial; color:var(--text); background:var(--bg)}
  .page{max-width:980px; margin:28px auto; padding:0 16px}

  .hero{background:linear-gradient(135deg,var(--accent) 0%, var(--accent-700) 60%); color:#fff; border-radius:18px; box-shadow:var(--ring); padding:18px 20px 14px}
  .hero h1{margin:0; font-weight:800}
  .hero small{font-weight:700; opacity:.95}
  .badges{display:flex; gap:14px; margin-top:8px; flex-wrap:wrap}
  .badge{display:inline-flex; align-items:center; gap:8px; background:rgba(255,255,255,.12); padding:6px 10px; border-radius:999px; font-weight:700}
  .dot{width:6px; height:6px; background:#60a5fa; border-radius:50%}

  .controls{display:flex; align-items:center; gap:12px; margin-top:14px; flex-wrap:wrap}
  .right{margin-left:auto; display:flex; align-items:center; gap:10px}
  .btn{background:#fff; color:#0b1220; border:1px solid rgba(15,23,42,.08); padding:10px 14px; border-radius:12px; font-weight:800; cursor:pointer}
  .btn[disabled]{opacity:.6; cursor:not-allowed}
  .btn:hover{background:#f8fafc}
  #timerEl{background:#fff; color:#0b1220; font-weight:800; padding:10px 14px; border-radius:12px; box-shadow:var(--soft); min-width:84px; text-align:center}

  .section{background:var(--card); border-radius:var(--radius); box-shadow:var(--ring); padding:18px; margin-top:18px}
  .section h3{margin:0 0 10px; font-size:12px; color:#6b7280; text-transform:uppercase; letter-spacing:.14em}
  .scroll{max-height:210px; overflow:auto; border:1px solid #e5e7eb; border-radius:12px; padding:16px; background:#fff}
  .inputbox{min-height:160px; overflow:auto; border:1px solid #e5e7eb; border-radius:12px; padding:16px; background:#f8fafc}

  /* Typing visuals */
  #textDisplay span.ok{ color:#6b7280; }
  #textDisplay span.err{ color:var(--err-red); }
  #textDisplay span.cur{ background:var(--cur-yellow); color:#111827; padding:2px 3px; border-radius:4px }

  .grid{display:grid; grid-template-columns:repeat(2,minmax(0,1fr)); gap:14px}
  .stat{border:1px solid #e5e7eb; border-radius:14px; padding:14px 16px; background:#fff}
  .stat small{display:block; color:#6b7280; font-weight:700; text-transform:uppercase; letter-spacing:.12em}
  .value{font-size:20px; font-weight:800; margin-top:6px}
  .value .u{font-size:11px; color:#6b7280; font-weight:700; margin-left:4px}
  .final{margin-top:12px; display:flex; align-items:center; gap:12px; flex-wrap:wrap}
  .pill-fail{background:#fee2e2; color:#991b1b; border:1px solid #fecaca; font-weight:900; letter-spacing:.08em; padding:10px 18px; border-radius:12px}
  .pill-pass{background:#dcfce7; color:#065f46; border:1px solid #bbf7d0; font-weight:900; letter-spacing:.08em; padding:10px 18px; border-radius:12px}
  .note{color:#6b7280}
  .hidden{display:none}

  /* Toast */
  #toastWrap{ display:none; margin-top:12px; }
  #toast{
    margin:0 auto; max-width:820px; padding:12px 16px; border-radius:10px;
    background:#fee2e2; color:#7f1d1d; border:1px solid #fecaca;
    font-weight:800; text-align:center; box-shadow:var(--ring);
    opacity:0; transition:opacity .25s ease;
  }
  #toastWrap.show{ display:block; }
  #toastWrap.show #toast{ opacity:1; }

  /* Modal */
  .modal-backdrop{
    position:fixed; inset:0; background:rgba(15,23,42,.55);
    display:none; align-items:center; justify-content:center; z-index:50;
  }
  .modal{background:#fff; width:min(760px,calc(100% - 24px)); border-radius:16px; box-shadow:var(--ring); padding:18px;}
  .modal h2{margin:0 0 10px; font-size:18px; font-weight:800}
  .modal .body{max-height:52vh; overflow:auto; border:1px solid #e5e7eb; border-radius:10px; padding:12px; background:#f8fafc;}
  .modal .body ol{margin:0; padding-left:20px;}
  .modal .body li{margin:6px 0;}
  .modal .actions{display:flex; justify-content:flex-end; gap:10px; margin-top:12px}
  .modal .actions .btn-primary{background:var(--accent); color:#fff; border:none}
  .modal .actions .btn-primary:hover{background:var(--accent-700)}
  .modal-backdrop.show{display:flex}

  /* Comparison UI */
  .cmp-wrap{margin-top:14px}
  .cmp-columns{display:grid; grid-template-columns:1fr 1fr; gap:12px}
  .cmp-box{border:1px solid #e5e7eb; border-radius:12px; padding:12px; background:#fff; max-height:240px; overflow:auto}
  .cmp-box h4{margin:0 0 8px; font-size:12px; color:#6b7280; letter-spacing:.1em; text-transform:uppercase}
  .w-ok{color:#6b7280}
  .w-partial{color:#b45309; text-decoration:underline; text-decoration-thickness:2px; text-underline-offset:3px}
  .w-full{color:#b91c1c; font-weight:700}
  .w-miss{color:#9ca3af; font-style:italic}
  .w-extra{color:#7c3aed; font-weight:700}

  @media (max-width:820px){.grid{grid-template-columns:1fr} .cmp-columns{grid-template-columns:1fr}}
</style>
</head>
<body>
  <div class="page">
    <header class="hero">
      <h1>UPSSSC <small>Junior Assistant Typing Test</small></h1>
      <div class="badges">
        <span class="badge"><span class="dot"></span> English: <strong>30 WPM</strong></span>
        <span class="badge"><span class="dot"></span> Hindi: <strong>25 WPM</strong></span>
        <span class="badge"><span class="dot"></span> Duration: <strong>5 + 5 Minutes</strong></span>
      </div>

      <div class="controls">
        <div class="left">
          <span id="stageLabel" style="font-weight:800">Stage: <u>English</u> → Hindi</span>

          <label id="passageLabel" style="color:#eaf7ee; font-weight:700; margin-left:12px;">Passage:</label>
          <select id="passageSet" style="margin-right:8px;"></select>

          <label id="fontLabel" class="hidden" style="color:#eaf7ee; font-weight:700; margin-left:12px;">Hindi Font:</label>
          <select id="hindiFont" class="hidden">
            <option value="Mangal" selected>Mangal (Inscript)</option>
            <option value="Kruti Dev 010">Kruti Dev 010</option>
          </select>
        </div>

        <div class="right">
          <button id="startBtn" class="btn" disabled>Loading…</button>
          <span id="timerEl">5:00</span>
          <button id="submitBtn" class="btn hidden">Submit</button>
          <button id="resetBtn" class="btn">Reset</button>
        </div>
      </div>
    </header>

    <!-- Toast -->
    <div id="toastWrap"><div id="toast">⚠️ CTRL/CMD or Paste not allowed</div></div>

    <!-- Reference Text -->
    <section class="section">
      <h3>Reference Text</h3>
      <div id="textDisplay" class="scroll">Select a passage and click “Start”.</div>
    </section>

    <!-- Typing Area -->
    <section class="section">
      <h3>Your Typing Area</h3>
      <div class="inputbox" id="inputWrapper">
        <textarea id="inputArea" placeholder="Start typing here..." disabled
          autocorrect="off" autocomplete="off" autocapitalize="off" spellcheck="false"
          style="width:100%; height:140px; border:none; outline:none; background:transparent; font-size:14px; line-height:1.6;"></textarea>
      </div>
      <small class="note">Backspace/Delete/Cut are limited to the <b>current word and immediate previous word only</b>. Once a space is typed, immediate previous word edit allowed; everything before gets locked.</small>
    </section>

    <!-- Results -->
    <section class="section">
      <h3>Test Results</h3>
      <div id="bothResults" class="hidden">
        <div class="grid">
          <div class="stat"><small>EN Gross</small><div id="grossEN" class="value">0.00<span class="u"> WPM</span></div></div>
          <div class="stat"><small>EN Net</small><div id="netEN" class="value">0.00<span class="u"> WPM</span></div></div>
          <div class="stat"><small>HI Gross</small><div id="grossHI" class="value">0.00<span class="u"> WPM</span></div></div>
          <div class="stat"><small>HI Net</small><div id="netHI" class="value">0.00<span class="u"> WPM</span></div></div>
        </div>
        <div class="grid" style="margin-top:10px">
          <div class="stat"><small>EN Errors</small><div class="value"><span id="fullEN">0</span> full, <span id="partialEN">0</span> partial</div></div>
          <div class="stat"><small>HI Errors</small><div class="value"><span id="fullHI">0</span> full, <span id="partialHI">0</span> partial</div></div>
        </div>

        <!-- KPM + Totals -->
        <div class="grid" style="margin-top:10px">
          <div class="stat">
            <small>EN Keystrokes / Min</small>
            <div id="kpmEN" class="value">0<span class="u"> KPM</span></div>
          </div>
          <div class="stat">
            <small>EN Totals</small>
            <div class="value">
              <span id="totalKeysEN">0</span><span class="u"> KS</span>
              &nbsp;•&nbsp;
              <span id="totalWordsEN">0.00</span><span class="u"> Words</span>
            </div>
          </div>
          <div class="stat">
            <small>HI Keystrokes / Min</small>
            <div id="kpmHI" class="value">0<span class="u"> KPM</span></div>
          </div>
          <div class="stat">
            <small>HI Totals</small>
            <div class="value">
              <span id="totalKeysHI">0</span><span class="u"> KS</span>
              &nbsp;•&nbsp;
              <span id="totalWordsHI">0.00</span><span class="u"> Words</span>
            </div>
          </div>
        </div>

        <div class="final">
          <div id="badgeEN" class="pill-fail">EN: FAIL</div>
          <div id="badgeHI" class="pill-fail">HI: FAIL</div>
          <div id="badgeOverall" class="pill-fail">OVERALL: FAIL</div>
          <span class="note">Both languages must meet minimum net WPM.</span>
        </div>

        <!-- Final Comparisons -->
        <div id="comparisonWrap" class="cmp-wrap hidden">
          <h3>Original vs Typed — Comparison</h3>
          <div class="cmp-columns">
            <div class="cmp-box">
              <h4>English (Original → Typed)</h4>
              <div id="cmpEN"></div>
            </div>
            <div class="cmp-box">
              <h4>Hindi (Original → Typed)</h4>
              <div id="cmpHI"></div>
            </div>
          </div>
        </div>

      </div>
      <div id="preResultsNote" class="note">Results appear after each stage and a combined summary at the end.</div>
    </section>
  </div>

  <!-- Instruction Modal (shown once, before English stage) -->
  <div id="instrBackdrop" class="modal-backdrop" role="dialog" aria-modal="true" aria-labelledby="instrTitle">
    <div class="modal">
      <h2 id="instrTitle">Instructions</h2>
      <div id="instrBody" class="body"></div>
      <div class="actions">
        <button id="instrCancel" class="btn">Cancel</button>
        <button id="instrOk" class="btn btn-primary">I Understand</button>
      </div>
    </div>
  </div>

<script>
document.addEventListener('DOMContentLoaded', function(){
  /* ===== Elements ===== */
  const els = {
    stageLabel: document.getElementById('stageLabel'),
    textDisplay: document.getElementById('textDisplay'),
    inputArea:  document.getElementById('inputArea'),
    startBtn:   document.getElementById('startBtn'),
    submitBtn:  document.getElementById('submitBtn'),
    resetBtn:   document.getElementById('resetBtn'),
    timerEl:    document.getElementById('timerEl'),
    bothResults:document.getElementById('bothResults'),
    preResultsNote: document.getElementById('preResultsNote'),
    grossEN:    document.getElementById('grossEN'),
    netEN:      document.getElementById('netEN'),
    fullEN:     document.getElementById('fullEN'),
    partialEN:  document.getElementById('partialEN'),
    grossHI:    document.getElementById('grossHI'),
    netHI:      document.getElementById('netHI'),
    fullHI:     document.getElementById('fullHI'),
    partialHI:  document.getElementById('partialHI'),
    badgeEN:    document.getElementById('badgeEN'),
    badgeHI:    document.getElementById('badgeHI'),
    badgeOverall: document.getElementById('badgeOverall'),
    passageSet: document.getElementById('passageSet'),
    hindiFont:  document.getElementById('hindiFont'),
    fontLabel:  document.getElementById('fontLabel'),
    toastWrap:  document.getElementById('toastWrap'),
    toast:      document.getElementById('toast'),
    instrBackdrop: document.getElementById('instrBackdrop'),
    instrBody: document.getElementById('instrBody'),
    instrOk: document.getElementById('instrOk'),
    instrCancel: document.getElementById('instrCancel'),
  };

  /* ===== Instruction HTML ===== */
  const INSTRUCTIONS_HTML = `
    <ol>
      <li>The candidates will be provided with the master text passage of about 1500 key depressions in English.</li>
      <li>The typing can be either word based typing or key strokes based typing.</li>
      <li>For example, 35 w.p.m. ≈ 10500 key depressions/hour and 30 w.p.m. ≈ 9000 key depressions/hour.</li>
      <li>The duration of the English typing test is 05:00 minutes.</li>
      <li>The countdown timer (top-right) shows remaining time. When it reaches zero, the test ends automatically.</li>
      <li>Repeating the passage is not required. You may revise and correct mistakes within the time.</li>
      <li>After punctuation, insert only one space. Follow the question paper precisely.</li>
      <li>One “Word” = alphanumeric keys followed by a space.</li>
      <li>After pressing Submit, no further editing is possible.</li>
      <li>If the computer locks/restarts or you need help, inform the invigilator immediately.</li>
      <li>On auto-restart, you will be provided the full time again.</li>
      <li>After typing the given number of words in the master text, the spacebar won’t add more words (non-space characters still allowed).</li>
    </ol>`;

  /* ===== State ===== */
  let intervalId = null;
  let timeLeft = 300;
  let started = false;
  let stage = 'EN';       // 'EN' -> 'HI'
  let passage = '';
  let startedAt = null;
  let results = { EN:null, HI:null };
  let instructionsShownOnce = false;

  let passageSets = [];
  let englishPassage = "";
  let hindiPassage   = "";

  /* ===== Toast ===== */
  let toastTimer = null;
  function showToast(msg){
    els.toast.textContent = msg;
    els.toastWrap.classList.add('show');
    clearTimeout(toastTimer);
    toastTimer = setTimeout(()=> els.toastWrap.classList.remove('show'), 1600);
  }

  /* ===== Helpers ===== */
  function wordsOf(text){ return text && text.length ? text.trim().split(/\s+/) : []; }
  function setPassage(text){
    const words = text.split(/\s+/);
    els.textDisplay.innerHTML = words.map((w,i)=>`<span data-i="${i}">${w}</span>`).join(' ');
  }
  function setFonts(){
    if (stage === 'HI'){
      const f = (els.hindiFont.value || 'Mangal') + ", Inter, system-ui";
      els.textDisplay.style.fontFamily = f;
      els.inputArea.style.fontFamily   = f;
    } else {
      els.textDisplay.style.fontFamily = 'Inter, system-ui';
      els.inputArea.style.fontFamily   = 'Inter, system-ui';
    }
  }
  function applySet(id){
    const set = (passageSets || []).find(s=>s.id===id) || passageSets[0];
    if (!set) return;
    englishPassage = (set.english||'').trim();
    hindiPassage   = (set.hindi||'').trim();
    els.textDisplay.textContent = 'Select “Start” to begin.';
  }
  function renderTime(){
    const m = Math.floor(timeLeft/60), s = String(timeLeft%60).padStart(2,'0');
    els.timerEl.textContent = m + ":" + s;
  }
  function setButtonsRunning(running){
    els.startBtn.disabled = running;
    els.resetBtn.disabled = running;
    els.submitBtn.disabled = !running ? true : false;
    if (els.passageSet) els.passageSet.disabled = running;
  }
  function resetAll(){
    if (intervalId) { clearInterval(intervalId); intervalId=null; }
    timeLeft=300; started=false; stage='EN'; results.EN=results.HI=null;
    els.timerEl.textContent='5:00';
    els.textDisplay.textContent='Select a passage and click “Start”.';
    els.inputArea.value=''; els.inputArea.disabled=true; els.submitBtn.classList.add('hidden');
    els.bothResults.classList.add('hidden'); els.preResultsNote.classList.remove('hidden');
    els.startBtn.textContent='Start English';
    els.stageLabel.innerHTML='Stage: <u>English</u> → Hindi';
    els.fontLabel.classList.add('hidden'); els.hindiFont.classList.add('hidden');
    setFonts(); setPassage('');
    setButtonsRunning(false);
    lockIdx = -1; prevLockIdx = -1; lastVal = '';
    snapshotTextarea();
  }

  /* ===== CURRENT + PREVIOUS WORD LOCK ===== */
  function computeLockIndex(val){
    const spaces = [];
    for (let i = 0; i < val.length; i++){
      if (val[i] === ' ') spaces.push(i);
    }
    if (spaces.length <= 1) return -1;      // <2 spaces → no lock yet
    return spaces[spaces.length - 2];       // boundary AT the second-last space
  }
  function nextLockIndex(currentVal, currentLock){
    const cand = computeLockIndex(currentVal);
    if (currentLock == null || currentLock < 0) return cand;
    return Math.max(currentLock, cand);
  }
  let lockIdx = -1;
  let prevLockIdx = -1;
  let lastVal = '';
  let lastSelStart = 0;
  let lastSelEnd = 0;

  function snapshotTextarea(){
    lastVal = els.inputArea.value;
    prevLockIdx = lockIdx;
    try{
      lastSelStart = els.inputArea.selectionStart;
      lastSelEnd   = els.inputArea.selectionEnd;
    }catch(_){}
  }

  function violatesPrefixLock(prev, next, boundary){
    if (boundary < 0) return false;
    return next.slice(0, boundary + 1) !== prev.slice(0, boundary + 1);
  }

  /* ===== Flow ===== */
  function actuallyStartStage(){
    started = true; timeLeft=300; startedAt=Date.now(); els.timerEl.textContent='5:00';
    els.inputArea.value=''; els.inputArea.disabled=false; els.inputArea.focus();
    els.submitBtn.classList.remove('hidden'); els.preResultsNote.classList.remove('hidden');
    setButtonsRunning(true);

    if (stage === 'EN'){
      passage = englishPassage;
      els.stageLabel.innerHTML='Stage: <b>English</b> → Hindi';
      els.startBtn.textContent='Running…';
      els.fontLabel.classList.add('hidden'); els.hindiFont.classList.add('hidden');
    } else {
      passage = hindiPassage;
      els.stageLabel.innerHTML='Stage: English → <b>Hindi</b>';
      els.startBtn.textContent='Running…';
      els.fontLabel.classList.remove('hidden'); els.hindiFont.classList.remove('hidden');
    }
    setPassage(passage); setFonts(); highlightProgress();

    lockIdx = -1; prevLockIdx = -1; lastVal = '';
    snapshotTextarea();

    renderTime();
    if (intervalId) clearInterval(intervalId);
    intervalId = setInterval(function(){
      timeLeft--;
      renderTime();
      if (timeLeft <= 0){
        clearInterval(intervalId); intervalId=null;
        finishStage();
      }
    }, 1000);
  }

  function openInstructionsAndStart(){
    els.instrBody.innerHTML = INSTRUCTIONS_HTML;
    els.instrBackdrop.classList.add('show');

    const ok = ()=>{ els.instrBackdrop.classList.remove('show'); instructionsShownOnce = true; actuallyStartStage(); };
    const cancel = ()=>{ els.instrBackdrop.classList.remove('show'); setButtonsRunning(false); };

    const onKey = (e)=>{ if (e.key==='Escape'){ cancel(); } };
    document.addEventListener('keydown', onKey, { once:true });

    els.instrOk.onclick = ok;
    els.instrCancel.onclick = cancel;
  }

  function startStage(){
    if (started) return;
    setButtonsRunning(true);
    if (!instructionsShownOnce && stage === 'EN'){ openInstructionsAndStart(); }
    else { actuallyStartStage(); }
  }

  function finishStage(){
    els.inputArea.disabled=true; els.submitBtn.classList.add('hidden');
    const stageResult = computeResults(); results[stage]=stageResult;
    setButtonsRunning(false);

    if (stage==='EN'){
      let prep=8; els.textDisplay.innerHTML='Hindi starts in <b>'+prep+'</b> seconds… Select font above if needed.';
      const prepInt=setInterval(function(){
        prep--; els.textDisplay.innerHTML='Hindi starts in <b>'+prep+'</b> seconds… Select font above if needed.';
        if(prep<=0){ clearInterval(prepInt); stage='HI'; els.timerEl.textContent='5:00'; els.startBtn.textContent='Start Hindi'; startStage(); }
      },1000);
    } else {
      showCombinedResults(); els.startBtn.textContent='Restart';
    }
    started=false;
  }

  /* ===== Scoring & Highlights (with Partial) ===== */
  function computeResults(){
    const elapsedSec = Math.max(1, Math.round((Date.now()-startedAt)/1000));
    const minutes = elapsedSec/60;

    const refWords   = passage.split(/\s+/);
    const typedRaw   = els.inputArea.value;                 // includes spaces
    const typedWords = wordsOf(typedRaw);

    // Classify only for typed words (omissions ignored)
    let full = 0, partial = 0;

    const typedLen = typedWords.length;
    const refLen   = refWords.length;
    const overlap  = Math.min(typedLen, refLen);

    for (let i=0; i<overlap; i++){
      const rw = refWords[i], tw = typedWords[i];
      if (rw === tw) continue;

      if (isPartial(rw, tw)) partial++;
      else full++;
    }
    // extra typed words beyond reference => full errors
    if (typedLen > refLen) full += (typedLen - refLen);

    // Keystrokes and words typed
    const totalKeystrokes = typedRaw.length;   // space counts as 1 keystroke
    const wordsTyped      = totalKeystrokes / 5;

    // Penalty model (hidden): based on FULL errors only
    const graceKS = 5;                  // 5 erroneous keystrokes allowed
    const errorKSRaw = full * 5;        // 1 full error ≈ 5 erroneous keystrokes
    const extraErrorKS = Math.max(0, errorKSRaw - graceKS);
    const penaltyKS = extraErrorKS * 25;

    const netKeystrokes = Math.max(0, totalKeystrokes - penaltyKS);
    const netWords      = netKeystrokes / 5;

    // Speeds
    const grossKPM = totalKeystrokes / minutes;
    const netKPM   = netKeystrokes   / minutes;
    const grossWPM = wordsTyped / 5;   // 5-minute stage
    const netWPM   = netWords  / 5;    // 5-minute stage

    // Pass/Fail
    const minSpeed = stage === 'HI' ? 25 : 30;
    const passed = netWPM >= minSpeed;

    // Highlights — move CURSOR to NEXT word if a trailing space was just typed
    const spans = els.textDisplay.querySelectorAll('span');
    for (let n=0;n<spans.length;n++){ spans[n].classList.remove('ok','err','cur'); }

    const endsWithSpace = typedRaw.endsWith(' ');
    for (let i=0;i<refWords.length;i++){
      const span = spans[i];
      const tw = typedWords[i];
      if (!span) continue;
      if (tw == null) continue;
      if (tw === refWords[i]) span.classList.add('ok'); else span.classList.add('err');
    }
    const curIndex = (() => {
      if (endsWithSpace) return Math.min(typedWords.length, refWords.length - 1);
      return Math.max(0, typedWords.length - 1);
    })();
    const curSpan = spans[curIndex];
    if (curSpan){ curSpan.classList.add('cur'); curSpan.scrollIntoView({block:'nearest', inline:'nearest'}); }

    // Bind to UI
    if (stage==='EN'){
      els.grossEN.innerHTML = grossWPM.toFixed(2)+'<span class="u"> WPM</span>';
      els.netEN.innerHTML   = netWPM.toFixed(2)+'<span class="u"> WPM</span>';

      byId('kpmEN').innerHTML         = Math.round(grossKPM)+'<span class="u"> KPM</span>';
      byId('totalKeysEN').textContent = totalKeystrokes.toString();
      byId('totalWordsEN').textContent= wordsTyped.toFixed(2);

      els.fullEN.textContent    = full.toString();
      els.partialEN.textContent = partial.toString();

      els.bothResults.classList.remove('hidden'); els.preResultsNote.classList.add('hidden');
      els.badgeEN.className = passed ? 'pill-pass' : 'pill-fail';
      els.badgeEN.textContent = 'EN: ' + (passed ? 'PASS' : 'FAIL');

    } else {
      els.grossHI.innerHTML = grossWPM.toFixed(2)+'<span class="u"> WPM</span>';
      els.netHI.innerHTML   = netWPM.toFixed(2)+'<span class="u"> WPM</span>';

      byId('kpmHI').innerHTML         = Math.round(grossKPM)+'<span class="u"> KPM</span>';
      byId('totalKeysHI').textContent = totalKeystrokes.toString();
      byId('totalWordsHI').textContent= wordsTyped.toFixed(2);

      els.fullHI.textContent    = full.toString();
      els.partialHI.textContent = partial.toString();

      els.bothResults.classList.remove('hidden'); els.preResultsNote.classList.add('hidden');
      els.badgeHI.className = passed ? 'pill-pass' : 'pill-fail';
      els.badgeHI.textContent = 'HI: ' + (passed ? 'PASS' : 'FAIL');
    }

    // return with raw strings (for final comparisons)
    return {
      grossWPM, netWPM, grossKPM, netKPM,
      fullErrors: full, partialErrors: partial,
      totalKeystrokes, wordsTyped, netWords, netKeystrokes,
      typedRaw, refRaw: passage, typedWords, refWords,
      passed
    };

    function byId(id){ return document.getElementById(id); }
  }

  // === Partial detection helpers ===
  function isPartial(ref, typed){
    if (ref.toLowerCase() === typed.toLowerCase()) return true;
    const rNP = stripPunct(ref).toLowerCase();
    const tNP = stripPunct(typed).toLowerCase();
    if (rNP === tNP && rNP.length > 0) return true;
    const dist = damerauLevenshtein(ref, typed);
    return dist <= 2; // near-miss
  }
  function stripPunct(s){
    return s.replace(/[^0-9A-Za-z\u0900-\u097F]/g, '');
  }
  function damerauLevenshtein(a, b){
    const al = a.length, bl = b.length;
    if (al === 0) return bl; if (bl === 0) return al;
    const da = Object.create(null);
    const d = Array(al + 2).fill(null).map(()=>Array(bl + 2).fill(0));
    const INF = al + bl;
    d[0][0] = INF;
    for (let i=0;i<=al;i++){ d[i+1][1]=i; d[i+1][0]=INF; }
    for (let j=0;j<=bl;j++){ d[1][j+1]=j; d[0][j+1]=INF; }
    for (let i=1;i<=al;i++){
      let db = 0;
      for (let j=1;j<=bl;j++){
        const i1 = da[b[j-1]] || 0;
        const j1 = db;
        let cost = 1;
        if (a[i-1] === b[j-1]){ cost = 0; db = j; }
        d[i+1][j+1] = Math.min(
          d[i][j] + cost,
          d[i+1][j] + 1,
          d[i][j+1] + 1,
          d[i1][j1] + (i - i1 - 1) + 1 + (j - j1 - 1)
        );
      }
      da[a[i-1]] = i;
    }
    return d[al+1][bl+1];
  }

  function showCombinedResults(){
    const enPass = results.EN && results.EN.passed === true;
    const hiPass = results.HI && results.HI.passed === true;
    const overallPass = enPass && hiPass;
    els.badgeOverall.className = overallPass ? 'pill-pass' : 'pill-fail';
    els.badgeOverall.textContent = 'OVERALL: ' + (overallPass ? 'PASS' : 'FAIL');

    // Build final comparisons for EN & HI
    const wrap = document.getElementById('comparisonWrap');
    const cmpEN = document.getElementById('cmpEN');
    const cmpHI = document.getElementById('cmpHI');

    if (results.EN){
      cmpEN.innerHTML = buildComparisonHTML(results.EN.refWords || [], results.EN.typedWords || []);
    } else { cmpEN.innerHTML = '<em class="w-miss">English not attempted.</em>'; }

    if (results.HI){
      cmpHI.innerHTML = buildComparisonHTML(results.HI.refWords || [], results.HI.typedWords || []);
    } else { cmpHI.innerHTML = '<em class="w-miss">Hindi not attempted.</em>'; }

    wrap.classList.remove('hidden');
  }

  // Build side-by-side tokens: we render a single line "Original → Typed"
  function buildComparisonHTML(refWords, typedWords){
    const maxLen = Math.max(refWords.length, typedWords.length);
    const parts = [];
    for (let i=0;i<maxLen;i++){
      const rw = refWords[i], tw = typedWords[i];
      if (rw == null && tw != null){
        parts.push(span('w-extra', escapeHTML(tw)) + ' ');
      } else if (rw != null && tw == null){
        parts.push(span('w-miss', escapeHTML(rw)) + ' ');
      } else if (rw != null && tw != null){
        if (rw === tw){
          parts.push(span('w-ok', escapeHTML(rw)) + ' ');
        } else if (isPartial(rw, tw)){
          // show ref~typed for partial
          parts.push(span('w-partial', escapeHTML(tw)) + ' ');
        } else {
          parts.push(span('w-full', escapeHTML(tw)) + ' ');
        }
      }
    }
    return parts.join('');
  }
  function span(cls, txt){ return `<span class="${cls}">${txt}</span>`; }
  function escapeHTML(s){ return s.replace(/[&<>"]/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[c])); }

  function highlightProgress(){
    const refWords = passage.split(/\s+/);
    const val = els.inputArea.value;
    const typedWords = wordsOf(val);
    const spans = els.textDisplay.querySelectorAll('span');

    for (let i=0;i<spans.length;i++){
      const span = spans[i]; span.classList.remove('ok','err','cur');
      const tw = typedWords[i]; if (tw==null) continue;
      if (tw === refWords[i]) span.classList.add('ok'); else span.classList.add('err');
    }

    // Move highlight to next word immediately if the last char is space
    const endsWithSpace = val.endsWith(' ');
    const curIndex = endsWithSpace
      ? Math.min(typedWords.length, refWords.length - 1)
      : Math.max(0, typedWords.length - 1);

    const curSpan = spans[curIndex];
    if (curSpan){ curSpan.classList.add('cur'); curSpan.scrollIntoView({block:'nearest', inline:'nearest'}); }
  }

  /* ===== Global guards ===== */
  window.addEventListener('keydown', function(e){
    if (!started) return;
    if (e.key === 'F5' || ((e.ctrlKey || e.metaKey) && (e.key.toLowerCase() === 'r'))){
      showToast('⚠️ CTRL/CMD or Paste not allowed');
      e.preventDefault();
    }
  });
  els.inputArea.addEventListener('select', snapCaretIfNeeded);
  document.addEventListener('selectionchange', function(){
    if (!started) return;
    if (document.activeElement === els.inputArea) snapCaretIfNeeded();
  });
  function snapCaretIfNeeded(){
    if (lockIdx < 0) return;
    const s = els.inputArea.selectionStart;
    const e = els.inputArea.selectionEnd;
    const leftMost = Math.min(s, e);
    if (leftMost <= lockIdx){
      const safe = Math.max(lockIdx + 1, Math.max(s, e));
      els.inputArea.setSelectionRange(safe, safe);
    }
  }

  /* ===== Edit guards ===== */
  els.inputArea.addEventListener('beforeinput', function(e){
    if (!started) return;

    snapshotTextarea();

    const t = e.inputType;

    if (t === 'insertFromPaste' || t === 'insertFromDrop'){
      showToast('⚠️ CTRL/CMD or Paste not allowed');
      e.preventDefault(); return;
    }

    const deletionTypes = new Set([
      'deleteContentBackward','deleteContentForward','deleteByCut',
      'deleteByComposition','historyUndo','deleteByDrag'
    ]);

    let s = e.target.selectionStart;
    let ed = e.target.selectionEnd;
    let aStart = s, aEnd = ed;
    if (t === 'insertText' || t === 'insertCompositionText'){
      aStart = s; aEnd = s;
      if (aStart <= prevLockIdx){ e.preventDefault(); return; }
    } else if (deletionTypes.has(t)){
      if (s === ed){
        if (t === 'deleteContentBackward'){ aStart = s - 1; aEnd = s; }
        else if (t === 'deleteContentForward'){ aStart = s; aEnd = s + 1; }
      }
      if (aStart <= prevLockIdx){ e.preventDefault(); return; }
    }
  });

  els.inputArea.addEventListener('keydown', function(e){
    if (!started) return;

    const changeKeys = ['Backspace','Delete','Enter',' ','ArrowLeft','Home'];
    if (e.key && changeKeys.includes(e.key)) snapshotTextarea();

    if (e.ctrlKey || e.metaKey){
      if (e.key !== 'Control' && e.key !== 'Meta'){ showToast('⚠️ CTRL/CMD or Paste not allowed'); }
      e.preventDefault(); return;
    }
    if (e.shiftKey && e.key === 'Insert'){
      showToast('⚠️ CTRL/CMD or Paste not allowed');
      e.preventDefault(); return;
    }

    const val = els.inputArea.value;

    if (e.key === ' '){
      const refCount = passage.split(/\s+/).length;
      const typedCount = (val.trim().length ? val.trim().split(/\s+/).length : 0);
      if (typedCount >= refCount){ e.preventDefault(); return; }
    }

    const boundary = (typeof prevLockIdx === 'number') ? prevLockIdx : lockIdx;

    if (boundary >= 0){
      if (e.key === 'ArrowLeft' || e.key === 'Home'){
        const s = els.inputArea.selectionStart;
        const ePos = els.inputArea.selectionEnd;
        const nextPos = (e.key==='Home') ? 0 : s - 1;
        if (Math.min(nextPos, ePos) <= boundary){
          els.inputArea.setSelectionRange(boundary + 1, boundary + 1);
          e.preventDefault(); return;
        }
      }

      if (e.key === 'Backspace' || e.key === 'Delete'){
        const s = els.inputArea.selectionStart;
        const ed = els.inputArea.selectionEnd;

        if (s !== ed){
          if (Math.min(s, ed) <= boundary){ e.preventDefault(); return; }
        } else {
          if (e.key === 'Backspace' && (s - 1) <= boundary){ e.preventDefault(); return; }
          if (e.key === 'Delete'    &&  s      <= boundary){ e.preventDefault(); return; }
        }
      }
    }
  });

  els.inputArea.addEventListener('input', function(){
    if (!started) return;

    const newVal = els.inputArea.value;

    if (violatesPrefixLock(lastVal, newVal, prevLockIdx)){
      els.inputArea.value = lastVal;
      const safe = Math.max(prevLockIdx + 1, 0);
      els.inputArea.setSelectionRange(safe, safe);
      showToast('Backspace limited to current & previous word');
      return;
    }

    highlightProgress();

    lockIdx = nextLockIndex(newVal, lockIdx);

    snapshotTextarea();
  });

  els.inputArea.addEventListener('paste', function(e){
    showToast('⚠️ CTRL/CMD or Paste not allowed');
    e.preventDefault();
  });

  window.addEventListener('beforeunload', function(e){ if (!started) return; e.preventDefault(); e.returnValue=''; });

  // Buttons
  els.startBtn.addEventListener('click', function(){
    if (els.startBtn.textContent==='Restart'){ resetAll(); return; }
    if (!instructionsShownOnce && stage === 'EN'){
      els.instrBody.innerHTML = INSTRUCTIONS_HTML;
      els.instrBackdrop.classList.add('show');
      els.instrOk.onclick = ()=>{ els.instrBackdrop.classList.remove('show'); instructionsShownOnce = true; actuallyStartStage(); };
      els.instrCancel.onclick = ()=>{ els.instrBackdrop.classList.remove('show'); setButtonsRunning(false); };
    } else {
      actuallyStartStage();
    }
  });
  els.submitBtn.addEventListener('click', function(){
    if (intervalId) clearInterval(intervalId); intervalId=null; finishStage();
  });
  els.resetBtn.addEventListener('click', resetAll);
  els.hindiFont.addEventListener('change', setFonts);
  els.passageSet.addEventListener('change', function(){ if (started) return; applySet(els.passageSet.value); });

  /* ===== Load passages.json ===== */
  async function loadPassages(){
    try{
      const res = await fetch('./passages.json?ts=' + Date.now(), { cache: 'no-store' });
      if(!res.ok) throw new Error('Failed to load passages.json: HTTP ' + res.status);
      const data = await res.json();

      let sets = [];
      if (Array.isArray(data.sets)) {
        sets = data.sets.filter(s => s && s.english && s.hindi);
      } else if (data.english && data.hindi) {
        sets = [{ id: data.id || 'default', label: data.label || 'Default', english: data.english, hindi: data.hindi }];
      } else {
        throw new Error('Invalid passages.json format');
      }
      if (!sets.length) throw new Error('No complete EN/HI pairs found');

      passageSets = sets.map((s, i) => Object.assign({ id: s.id || ('set-'+i), label: s.label || ('Set '+(i+1)) }, s));
      els.passageSet.innerHTML = passageSets.map(s => `<option value="${s.id}">${s.label}</option>`).join('');
      els.passageSet.value = passageSets[0].id;
      applySet(passageSets[0].id);

      els.startBtn.disabled = false;
      els.startBtn.textContent = 'Start English';
    }catch(e){
      console.error('[passages.json] load error:', e);
      passageSets = [{
        id:'default', label:'Default',
        english:"The Uttar Pradesh Subordinate Services Selection Commission conducts the typing test to check a candidate's ability to type accurately at a practical pace. During the examination you will copy the given passage within a strict five minute window. The objective is not only to reach a higher speed, but also to maintain precision while switching between words, punctuation and casing. Students are advised to focus on rhythm, keep their posture neutral and avoid looking at the keyboard. With consistent practice the gross speed and net speed both improve substantially.",
        hindi:"उत्तर प्रदेश अधीनस्थ सेवा चयन आयोग द्वारा आयोजित टाइपिंग परीक्षा का उद्देश्य अभ्यर्थियों की गति के साथ-साथ शुद्धता का मूल्यांकन करना है। पाँच मिनट की समयावधि में दिए गए अनुच्छेद को हूबहू टाइप करना होता है। ध्यान रखें कि शब्द, विराम-चिह्न और बड़े-छोटे अक्षरों में त्रुटि न हो। स्थिर गति और लय के साथ अभ्यास करने से सकल गति तथा शुद्ध टाइपिंग गति में लगातार सुधार आता है। अभ्यर्थियों को सही कीबोर्ड लेआउट का प्रयोग करते हुए स्क्रीन पर ध्यान केंद्रित रखना चाहिए।"
      }];
      els.passageSet.innerHTML = '<option value="default">Default</option>';
      els.passageSet.value = 'default';
      applySet('default');
      els.startBtn.disabled = false;
      els.startBtn.textContent = 'Start English';
      showToast('⚠️ Could not load passages.json — using built-in default.');
    }
  }

  // Init
  resetAll();
  loadPassages();
});
</script>
</body>
</html>


